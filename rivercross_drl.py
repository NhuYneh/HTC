# -*- coding: utf-8 -*-
"""rivercross_drl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/NhuYneh/85aa2bb9c260a329ad09a5eb22260c57/rivercross_drl.ipynb
"""

import numpy as np
from copy import copy

FARMER = 0
WOLF = 1
GOAT = 2
CABBAGE = 3

START_STATE = ['L','L','L','L']

def wolfRule(state):
    return state[FARMER] == state[WOLF] or state[WOLF] != state[GOAT]

def goatRule(state):
    return state[FARMER] == state[GOAT] or state[GOAT] != state[CABBAGE]

def validRule(state):
    return wolfRule(state) and goatRule(state)

def winRule(state):
    return state == ['R','R','R','R']

def generateMoves(state):
    for other in [FARMER, WOLF, GOAT, CABBAGE]:
        if state[FARMER] == state[other]:
            move = copy(state)
            move[FARMER] = 'L' if state[FARMER] == 'R' else 'R'
            move[other] = 'L' if state[other] == 'R' else 'R'
            yield move
            #return [move1, move2, move3 ]

def validMoves(state_list):
    return [ state for state in state_list if validRule(state)]

def depthFirstSearch(state, previous_states):
    previous_states.append(state)
    if winRule(state):
        return previous_states
    for move in validMoves(generateMoves(state)):
        if move not in previous_states:
            result = depthFirstSearch(move, previous_states)
            if result is not None:
                return result
            previous_states.pop()
    return None

depthFirstSearch(START_STATE,[])

def backtracking(state, path):
    if winRule(state):
        return path + [state]
    moves = validMoves(list(generateMoves(state)))

    for move in moves:
        if move not in path:
            result = backtracking(move, path + [state])
            if result:
                return result
    return None

solution = backtracking(START_STATE, [])
if solution:
    for step in solution:
        print(step)
else:
    print("No solution found.")

from collections import deque
def bfs(initial_state):
    queue = deque([(initial_state, [])])
    visited = set()

    while queue:
        current_state, path = queue.popleft()
        if winRule(current_state):
            return path + [current_state]
        state_tuple = tuple(current_state)
        if state_tuple in visited:
            continue
        visited.add(state_tuple)
        for move in generateMoves(current_state):
            if validRule(move) and tuple(move) not in visited:
                queue.append((move, path + [current_state]))

    return None


solution = bfs(START_STATE)

if solution:
    for step in solution:
        print(step)
else:
    print("No solution found.")

from heapq import heappush, heappop
def heuristic(state):
    return state.count('L') - 1

def a_star(initial_state):

    frontier = []
    heappush(frontier, (0, initial_state, []))


    visited = set()

    while frontier:
        f, current_state, path = heappop(frontier)

        if winRule(current_state):
            return path + [current_state]

        state_tuple = tuple(current_state)
        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        for move in generateMoves(current_state):
            if validRule(move) and tuple(move) not in visited:

                g = len(path) + 1
                h = heuristic(move)
                heappush(frontier, (g + h, move, path + [current_state]))

    return None


solution = a_star(START_STATE)


if solution:
    for step in solution:
        print(step)
else:
    print("No solution found.")

F = [1, 1, 2, 3, 5, 8, 13, 21, 34 ]
F[i+1] = F[i] + F[i-1]
#i= 1, F[1] = 1
#i=2, F[2] = 1
#i=3, F[3] = F[2] + F[1]

#Tim Fibnaci N
N=50
F = np.zeros(N+1, dtype=int)
F[0] = 1
F[1] = 1
for i in range(2,N+1):
  F[i] = round(F[i-1] + F[i-2],0)
print(F[N])

print(F)

def Fibo(n):
  if n ==0 or n==1:
    return 1
  else:
    return Fibo(n-1) + Fibo(n-2)

print(Fibo(10))